---
phase: 03-frontend-integration
plan: 02
type: execute
---

<objective>
Implement VRF multicall helper and transaction execution logic following the Cartridge VRF transaction flow pattern.

Purpose: Build the core VRF integration logic that constructs the proper multicall sequence (request_random â†’ generate_random_in_range) and executes it through the user's wallet.
Output: Working buildVrfCalls helper and transaction execution hook for VRF operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-integration/03-01-SUMMARY.md
@contract/src/random_range_generator.cairo

**Reference VRF multicall pattern:**
@/Users/akashbalasubramani/Desktop/referral/vrf/vrf/dojo/buildVrfCalls.ts

**VRF transaction flow:**
User multicall: [request_random, generate_random_in_range]
Paymaster wraps: [submit_random, request_random, generate_random_in_range, assert_consumed]
- request_random signals VRF request (no-op marker for paymaster)
- Contract's generate_random_in_range calls consume_random internally
- Paymaster handles submit_random (proof) and assert_consumed (validation)

**VRF provider address (Sepolia):** 0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f

**Source::Nonce encoding:** Source enum with Nonce = 0x0, pass [contractAddress, Source.Nonce, account.address] as calldata

**Contract ABI needs:**
- generate_random_in_range(min: u128, max: u128) -> u128
- get_last_random_number() -> (u128, u128, u128)

**Established patterns:**
- User only builds [request_random, their_contract_call] - paymaster wraps with VRF proof
- Source::Nonce(caller) for non-deterministic randomness
- Contract address needed for both request_random and actual call

**Tech stack:**
- starknet.js v6 multicall: account.execute([...calls])
- @starknet-react/core hooks: useAccount, useContract
- CallData.compile for calldata encoding
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contract constants and ABI</name>
  <files>frontend/src/contracts/constants.ts, frontend/src/contracts/RandomRangeGeneratorAbi.json</files>
  <action>Create frontend/src/contracts/ directory. In constants.ts: export const VRF_PROVIDER_ADDRESS = "0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f" (Sepolia VRF provider); export const RANDOM_RANGE_GENERATOR_ADDRESS = "0x0" as placeholder (will be updated after deployment in Phase 4); export enum Source { Nonce = "0x0", Salt = "0x1" }. Create RandomRangeGeneratorAbi.json by running `cd contract && scarb build --json > ../frontend/src/contracts/RandomRangeGeneratorAbi.json` OR manually extract ABI from contract/target/dev/*.contract_class.json after build. ABI should include generate_random_in_range and get_last_random_number functions. If scarb --json not available, manually copy ABI array from compiled contract_class.json.</action>
  <verify>constants.ts exports VRF_PROVIDER_ADDRESS and Source enum, RandomRangeGeneratorAbi.json exists with valid JSON array containing contract interface</verify>
  <done>Contract constants defined, ABI extracted from compiled contract, placeholder address ready for Phase 4</done>
</task>

<task type="auto">
  <name>Task 2: Implement buildVrfCalls helper</name>
  <files>frontend/src/utils/vrfHelpers.ts</files>
  <action>Create frontend/src/utils/vrfHelpers.ts. Import Call, CallData from starknet, Source and VRF_PROVIDER_ADDRESS from contracts/constants. Implement buildVrfCalls function: (1) Takes parameters: contractAddress (target contract), accountAddress (caller), calldata (for generate_random_in_range); (2) Creates request_random call: { contractAddress: VRF_PROVIDER_ADDRESS, entrypoint: "request_random", calldata: CallData.compile([contractAddress, Source.Nonce, accountAddress]) }; (3) Creates target contract call with provided contractAddress, entrypoint, calldata; (4) Returns array [requestRandomCall, targetCall]. CRITICAL: User multicall is ONLY these 2 calls - paymaster automatically wraps with submit_random/assert_consumed. Do NOT manually add submit_random or assert_consumed (no vrfProviderSecret handling - that's server-side). Follow simplified pattern: user sends request marker + their call, paymaster does VRF proof wrapping. Add JSDoc comments explaining the flow.</action>
  <verify>TypeScript compiles without errors, function signature is buildVrfCalls({ contractAddress, accountAddress, entrypoint, calldata }: { contractAddress: string, accountAddress: string, entrypoint: string, calldata: any[] }): Call[]</verify>
  <done>buildVrfCalls helper creates proper 2-call multicall: request_random marker + target contract call, ready for paymaster wrapping</done>
</task>

<task type="auto">
  <name>Task 3: Create transaction execution hook</name>
  <files>frontend/src/hooks/useVrfTransaction.ts</files>
  <action>Create frontend/src/hooks/useVrfTransaction.ts. Import useState from react, useAccount from @starknet-react/core, CallData from starknet, buildVrfCalls from utils/vrfHelpers, RANDOM_RANGE_GENERATOR_ADDRESS from contracts/constants. Implement useVrfTransaction hook: (1) State: txHash (string | null), loading (boolean), error (Error | null); (2) executeVrfCall async function: takes min: number, max: number; validates min < max; gets account from useAccount(); compiles calldata with CallData.compile({ min, max }); builds VRF calls using buildVrfCalls({ contractAddress: RANDOM_RANGE_GENERATOR_ADDRESS, accountAddress: account.address, entrypoint: "generate_random_in_range", calldata: [min, max] }); executes with account.execute(calls); sets txHash, handles loading states, catches errors; (3) Return { executeVrfCall, txHash, loading, error, reset: () => {/* reset state */} }. Add error handling for wallet not connected, transaction rejected, network errors. Use try-catch with clear error messages.</action>
  <verify>TypeScript compiles, hook exports { executeVrfCall, txHash, loading, error, reset }, executeVrfCall returns Promise<void></verify>
  <done>useVrfTransaction hook provides clean API: executeVrfCall(min, max) with loading/error states, txHash on success</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no TypeScript errors
- [ ] buildVrfCalls creates [request_random, generate_random_in_range] array
- [ ] useVrfTransaction hook compiles without errors
- [ ] Source.Nonce encoding matches reference pattern (0x0)
- [ ] VRF provider address constant is correct for Sepolia
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- buildVrfCalls helper follows Cartridge VRF multicall pattern
- useVrfTransaction hook provides clean transaction API
- TypeScript compiles without errors
- Ready for UI integration in 03-03
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-integration/03-02-SUMMARY.md`:

# Phase 03-02: VRF Multicall Implementation Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 03-03-PLAN.md (UI Components & Result Display)
</output>
