---
phase: 02-random-range-generation
plan: 01
type: execute
---

<objective>
Implement random number generation with accurate range mapping using VrfConsumerComponent.

Purpose: Enable cryptographically secure random number generation within user-specified ranges by integrating consume_random API and applying mathematically sound uniform distribution.
Output: Working generate_random_in_range and get_last_random_number functions with proper VRF consumption, storage, and event emission.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cairo-contract-foundation/01-01-SUMMARY.md
@contract/src/random_range_generator.cairo
@/Users/akashbalasubramani/Desktop/referral/vrf/vrf/src/mocks/vrf_consumer_mock.cairo

**Tech stack available:** cairo-2024_07, scarb-2.12.1, starknet-2.12.1, stark_vrf-0.1.1, cartridge_vrf-path

**Established patterns:**
- VrfConsumerComponent integration: component!() macro, substorage(v0), flat events
- Struct-based storage: RandomResult with value/min/max fields
- Interface-first design: trait defined before implementation

**Constraining decisions:**
- Phase 01: Used Map instead of deprecated LegacyMap for Cairo 2024_07 compatibility
- Phase 01: VrfConsumerComponent integration pattern established

**VRF consumption pattern from reference (vrf_consumer_mock.cairo:56-64):**
```cairo
fn dice(ref self: ContractState) -> u8 {
    let player_id = get_caller_address();
    let random: u256 = self.vrf_consumer.consume_random(Source::Nonce(player_id)).into();

    let dice_value = ((random % 6) + 1).try_into().unwrap();
    self.dice_value.write(dice_value);

    dice_value
}
```

**Key insights:**
- consume_random returns felt252, convert to u256 for arithmetic
- Source::Nonce(caller_address) for non-deterministic randomness
- Uniform distribution: min + (random % (max - min + 1))
- Store result and emit event after generation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_random_in_range function</name>
  <files>contract/src/random_range_generator.cairo</files>
  <action>
    Replace the stub implementation (lines 56-59) with full logic:

    1. Get caller address: `let caller = get_caller_address();`
    2. Validate range: assert min < max, panic if invalid
    3. Call consume_random: `let random: u256 = self.vrf_consumer.consume_random(Source::Nonce(caller)).into();`
    4. Apply uniform distribution: `let range_size: u256 = (max - min + 1).into();` then `let offset = random % range_size;` then `let value: u128 = (min.into() + offset).try_into().unwrap();`
    5. Store result: `self.last_result.write(caller, RandomResult { value, min, max });`
    6. Emit event: `self.emit(RandomGenerated { caller, value, min, max });`
    7. Return value

    Add necessary imports:
    - `use starknet::get_caller_address;`
    - `use cartridge_vrf::Source;`
    - `use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};`

    Follow the dice() pattern from vrf_consumer_mock.cairo:56-64. DO NOT use jsonwebtoken-style validation - Cairo uses assert! macro. DO NOT implement batch generation or history tracking - out of scope per PROJECT.md.
  </action>
  <verify>scarb build in contract/ directory exits 0, no type errors</verify>
  <done>Function consumes VRF randomness, validates range, applies uniform distribution, stores result, emits event, returns value</done>
</task>

<task type="auto">
  <name>Task 2: Implement get_last_random_number getter</name>
  <files>contract/src/random_range_generator.cairo</files>
  <action>
    Replace the stub implementation (lines 61-64) with:

    1. Get caller address: `let caller = get_caller_address();`
    2. Read stored result: `let result = self.last_result.read(caller);`
    3. Return tuple: `(result.value, result.min, result.max)`

    This returns (0, 0, 0) if no result stored yet (default RandomResult initialization). No need for explicit uninitialized check - Cairo's storage default is zero-initialized.

    Use StoragePointerReadAccess trait (already imported in Task 1). DO NOT add complex error handling or Option types - keep it simple per PROJECT.md minimal error handling principle.
  </action>
  <verify>scarb build succeeds, function signature matches interface</verify>
  <done>Getter returns stored (value, min, max) tuple for caller</done>
</task>

<task type="auto">
  <name>Task 3: Build and verify contract</name>
  <files>N/A</files>
  <action>
    Run final build verification:
    1. cd contract/
    2. scarb build
    3. Verify Sierra artifacts generated in target/dev/
    4. Check no warnings or errors

    Expected artifacts:
    - vrf_example_RandomRangeGenerator.contract_class.json
    - vrf_example_RandomRangeGenerator.compiled_contract_class.json

    If build fails, debug and fix before proceeding. Common issues: missing imports, type mismatches in arithmetic, incorrect trait bounds.
  </action>
  <verify>scarb build exits 0, contract_class.json and compiled_contract_class.json exist in target/dev/</verify>
  <done>Contract builds successfully with all functions implemented, ready for frontend integration</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `scarb build` succeeds without errors or warnings
- [ ] Sierra artifacts generated in contract/target/dev/
- [ ] generate_random_in_range calls consume_random with Source::Nonce
- [ ] Uniform distribution correctly applied: min + (random % (max - min + 1))
- [ ] Storage updated with RandomResult
- [ ] RandomGenerated event emitted
- [ ] get_last_random_number returns stored result
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors (N/A - Cairo only)
- No Cairo errors or warnings
- Contract ready for frontend integration in Phase 3
- Random range generation works with mathematically sound uniform distribution
  </success_criteria>

<output>
After completion, create `.planning/phases/02-random-range-generation/02-01-SUMMARY.md`:

# Phase 02-01: Random Range Generation Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- generate_random_in_range implemented with consume_random integration
- Uniform distribution range mapping with modulo arithmetic
- Storage update with RandomResult struct
- Event emission on random generation
- get_last_random_number getter for result retrieval
- Contract builds successfully

## Files Created/Modified

- `contract/src/random_range_generator.cairo` - Implemented random generation logic

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 3 (Frontend Integration).

Contract now has working random generation. Phase 3 can build React UI with:
- Wallet connection
- VRF multicall builder (request_random â†’ generate_random_in_range)
- Transaction execution
- Result display via get_last_random_number

No blockers.
</output>
