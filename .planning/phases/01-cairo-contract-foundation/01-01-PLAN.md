---
phase: 01-cairo-contract-foundation
plan: 01
type: execute
---

<objective>
Establish Cairo smart contract foundation with VrfConsumerComponent integration, storage schema, and build configuration.

Purpose: Create the structural foundation all VRF functionality depends on—proper component wiring, storage layout, and dependency setup.
Output: Buildable Cairo contract with VrfConsumerComponent integrated, ready for Phase 2 implementation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cairo-contract-foundation/DISCOVERY.md

**Reference patterns from VRF repository:**
- Component integration: /Users/akashbalasubramani/Desktop/referral/vrf/vrf/src/mocks/vrf_consumer_mock.cairo (lines 23-47)
- Component API: /Users/akashbalasubramani/Desktop/referral/vrf/vrf/src/vrf_consumer/vrf_consumer_component.cairo (lines 59-64)

**VRF Provider Address (Sepolia):** 0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f

**Key Patterns from Discovery:**
- Component requires: `component!()` macro, `#[substorage(v0)]` attribute, `#[flat]` events
- Two impls needed: VrfConsumerImpl (public), VrfConsumerInternalImpl (internal)
- Constructor calls `self.vrf_consumer.initializer(vrf_provider)`
- consume_random accessed via `self.vrf_consumer.consume_random(Source::Nonce(caller))`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Scarb project with VRF dependencies</name>
  <files>contract/Scarb.toml, contract/src/lib.cairo, contract/.gitignore</files>
  <action>
    Create contract/ directory. Initialize Scarb project with:

    **Scarb.toml:**
    - Package name: "vrf_random_range"
    - Cairo edition: "2024_07"
    - Dependencies:
      - starknet = "^2.12.1"
      - stark_vrf = "0.1.1"
      - cartridge_vrf via git: "https://github.com/cartridge-gg/vrf"
    - [[target.starknet-contract]] with sierra = true

    **src/lib.cairo:**
    - Empty module structure (mod random_range_generator;)
    - Placeholder for contract implementation

    **gitignore:**
    - target/ (Scarb build artifacts)

    Use exact dependency versions from DISCOVERY.md. Do NOT use scarb init command (creates wrong structure)—manually create files with correct configuration.
  </action>
  <verify>scarb --version succeeds, Scarb.toml parses correctly, directory structure matches contract/src/lib.cairo pattern</verify>
  <done>Scarb.toml exists with correct dependencies, src/lib.cairo created, .gitignore present, no syntax errors</done>
</task>

<task type="auto">
  <name>Task 2: Create contract with VrfConsumerComponent integration</name>
  <files>contract/src/random_range_generator.cairo</files>
  <action>
    Create contract following vrf_consumer_mock.cairo pattern (lines 15-48):

    **Required imports:**
    ```cairo
    use cartridge_vrf::Source;
    use cartridge_vrf::vrf_consumer::vrf_consumer_component::VrfConsumerComponent;
    use starknet::{ContractAddress, get_caller_address};
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    ```

    **Component setup:**
    - `component!(path: VrfConsumerComponent, storage: vrf_consumer, event: VrfConsumerEvent);`
    - `#[abi(embed_v0)] impl VrfConsumerImpl = VrfConsumerComponent::VrfConsumerImpl<ContractState>;`
    - `impl VrfConsumerInternalImpl = VrfConsumerComponent::InternalImpl<ContractState>;`

    **Interface:**
    - Define IRandomRangeGenerator trait with placeholder signatures:
      - `fn generate_random_in_range(ref self: TContractState, min: u128, max: u128) -> u128;`
      - `fn get_last_random_number(self: @TContractState) -> (u128, u128, u128);`

    **Constructor:**
    ```cairo
    #[constructor]
    fn constructor(ref self: ContractState, vrf_provider: ContractAddress) {
        self.vrf_consumer.initializer(vrf_provider);
    }
    ```

    **Stub implementation:**
    - Implement trait with placeholder functions (panic with "Not implemented" for Phase 2)
    - This validates structure compiles correctly

    Do NOT implement logic yet—focus on structure. Avoid implementing generate_random_in_range or get_last_random_number logic (Phase 2 work).
  </action>
  <verify>File exists, imports resolve, component macro compiles, constructor signature correct</verify>
  <done>Contract structure complete with component integration, interface defined, constructor implemented, stub functions present</done>
</task>

<task type="auto">
  <name>Task 3: Define storage schema and event structure</name>
  <files>contract/src/random_range_generator.cairo</files>
  <action>
    Add to existing contract file:

    **Storage (using struct-based approach from DISCOVERY.md):**
    ```cairo
    #[derive(Drop, Serde, starknet::Store)]
    struct RandomResult {
        value: u128,
        min: u128,
        max: u128,
    }

    #[storage]
    pub struct Storage {
        #[substorage(v0)]
        vrf_consumer: VrfConsumerComponent::Storage,
        last_result: LegacyMap<ContractAddress, RandomResult>,
    }
    ```

    **Events:**
    ```cairo
    #[derive(Drop, starknet::Event)]
    struct RandomGenerated {
        caller: ContractAddress,
        value: u128,
        min: u128,
        max: u128,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        #[flat]
        VrfConsumerEvent: VrfConsumerComponent::Event,
        RandomGenerated: RandomGenerated,
    }
    ```

    **Critical:** Ensure `#[substorage(v0)]` attribute present on vrf_consumer field. Ensure `#[flat]` attribute on VrfConsumerEvent. Storage field name (`vrf_consumer`) must match component macro's storage parameter. Use LegacyMap (not Map) for broader compatibility.

    Update lib.cairo to properly export the module.
  </action>
  <verify>Storage compiles with substorage attribute, events defined with flat attribute, struct derives correct traits</verify>
  <done>RandomResult struct defined, Storage includes component substorage and last_result map, Event enum includes both component and custom events, all attributes correct</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd contract && scarb build` succeeds without errors
- [ ] No warnings about missing attributes (substorage, flat)
- [ ] target/dev/ contains compiled Sierra artifacts
- [ ] Contract structure matches reference patterns from DISCOVERY.md
</verification>

<success_criteria>

- All 3 tasks completed
- Scarb project builds successfully
- VrfConsumerComponent properly integrated with correct attributes
- Storage schema defined with RandomResult struct
- Event structure includes both component and custom events
- No compilation errors or warnings
- Ready for Phase 2 implementation (generate_random_in_range logic)
</success_criteria>

<output>
After completion, create `.planning/phases/01-cairo-contract-foundation/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Cairo Contract Foundation Summary

**Cairo contract foundation established with VrfConsumerComponent integration and storage schema.**

## Accomplishments

- Scarb project initialized with VRF dependencies (cartridge_vrf, stark_vrf, starknet)
- Contract structure created with proper component integration (component macro, impls, substorage)
- Storage schema defined using RandomResult struct for per-user tracking
- Event structure configured with flattened component events
- Build pipeline verified (scarb build succeeds)

## Files Created/Modified

- `contract/Scarb.toml` - Project manifest with VRF dependencies
- `contract/src/lib.cairo` - Module exports
- `contract/src/random_range_generator.cairo` - Main contract with component integration
- `contract/.gitignore` - Build artifact exclusions

## Tech Stack Added

- Cairo 2024_07 edition
- starknet ^2.12.1
- stark_vrf 0.1.1
- cartridge_vrf (git)
- Scarb build system

## Patterns Established

- VrfConsumerComponent integration pattern (component macro, substorage, flat events)
- Struct-based storage (RandomResult) for cleaner state management
- Constructor pattern with VRF provider initialization

## Decisions Made

- Used struct-based storage (RandomResult) over separate maps for cleaner design
- Used LegacyMap for broader Cairo version compatibility
- Stubbed implementation functions to validate structure before logic

## Issues Encountered

None (or document any compilation issues resolved)

## Next Phase Readiness

**Ready for Phase 2 (Random Range Generation).**

Contract foundation complete. Phase 2 can now implement:
- `generate_random_in_range(min, max)` with consume_random integration
- Uniform distribution range mapping (min + random % (max - min + 1))
- `get_last_random_number()` getter from storage
- Event emission on generation

No blockers. VrfConsumerComponent integration verified via build.
</output>
